<!DOCTYPE html>
<html>
<head>
<title>Parachronic</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<script type="text/javascript" src="csound_loader.js"></script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.1/dat.gui.js"></script>
<script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.1.1/sprintf.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.js"></script>
<script type="text/javascript" src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"></script>
<script type="text/javascript" src="piano-roll.js"></script>
<!--
<script src="js/TrackballControls.js"></script>
<script src="js/sprintf.js"></script>
<script src="js/numeric.js"></script>
<script src="js/three.js"></script>
<script src="js/tinycolor.js"></script>
<script src="js/dat.gui.js"></script>
-->
</head>
<body class="w3-container w3-black">
<div class="w3-row-padding">
<div class="w3-half">
<textarea id="csd" class="w3-code" style="width:100%;height:50vh;box-sizing:border-box;background-color:MidnightBlue;color:NavajoWhite;">
<CsoundSynthesizer>
<CsOptions>
-dm195
</CsOptions>
<CsInstruments>
sr = 48000
ksmps = 128
nchnls = 2
nchnls_i = 1
0dbfs = 10000000

; Ensure the same random stream for each rendering.
; rand, randh, randi, rnd(x) and birnd(x) are not affected by seed.

;seed 81814
;seed 818145
seed 88818145

connect "Blower", "outleft", "ReverbSC", "inleft"
connect "Blower", "outright", "ReverbSC", "inright"
connect "Bower", "outleft", "ReverbSC", "inleft"
connect "Bower", "outright", "ReverbSC", "inright"
connect "Buzzer", "outleft", "ReverbSC", "inleft"
connect "Buzzer", "outright", "ReverbSC", "inright"
connect "Droner", "outleft", "ReverbSC", "inleft"
connect "Droner", "outright", "ReverbSC", "inright"
connect "FMWaterBell", "outleft", "ReverbSC", "inleft"
connect "FMWaterBell", "outright", "ReverbSC", "inright"
connect "Phaser", "outleft", "ReverbSC", "inleft"
connect "Phaser", "outright", "ReverbSC", "inright"
connect "Sweeper", "outleft", "ReverbSC", "inleft"
connect "Sweeper", "outright", "ReverbSC", "inright"
connect "Shiner", "outleft", "ReverbSC", "inleft"
connect "Shiner", "outright", "ReverbSC", "inright"
connect "ZakianFlute", "outleft", "ReverbSC", "inleft"
connect "ZakianFlute", "outright", "ReverbSC", "inright"
connect "ReverbSC", "outleft", "MasterOutput", "inleft"
connect "ReverbSC", "outright", "MasterOutput", "inright"

alwayson "Controls"
alwayson "ReverbSC"
alwayson "MasterOutput"

gk_overlap init 4.5

prealloc 1, 50
prealloc 2, 50
prealloc 3, 50
prealloc 4, 50
prealloc 5, 50
prealloc 6, 50
prealloc 7, 50
prealloc 8, 20
prealloc 9, 20

//////////////////////////////////////////////
// Original by Steven Yi.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
gk_FMWaterBell_level init 0
gi_FMWaterBell_attack init 0.002
gi_FMWaterBell_release init 0.01
gi_FMWaterBell_sustain init 20
gi_FMWaterBell_sustain_level init .1
gk_FMWaterBell_index init .5
gk_FMWaterBell_crossfade init .5
gk_FMWaterBell_vibrato_depth init 0.
gk_FMWaterBell_vibrato_rate init 6
gk_FMWaterBell_midi_dynamic_range init 127
gi_FMWaterBell_cosine ftgen 0, 0, 65537, 11, 1
instr FMWaterBell
i_instrument = p1
i_time = p2
i_duration = p3
; One of the envelopes in this instrument should be releasing, and use this:
i_sustain = 1000
;xtratim gi_FMWaterBell_attack + gi_FMWaterBell_release
p3 = p3 + gi_FMWaterBell_attack + gi_FMWaterBell_release
i_midi_key = p4
i_midi_dynamic_range = i(gk_FMWaterBell_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
if i_midi_key > 42 goto high_level
i_level_correction = -23.5
goto end_level
high_level:
i_level_correction = -20
end_level:
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization * 1.6
k_gain = ampdb(gk_FMWaterBell_level)
a_signal fmbell	1, i_frequency, gk_FMWaterBell_index, gk_FMWaterBell_crossfade, gk_FMWaterBell_vibrato_depth, gk_FMWaterBell_vibrato_rate, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine ;, gi_FMWaterBell_sustain
;a_envelope linsegr 0, gi_FMWaterBell_attack, 1, i_sustain, gi_FMWaterBell_sustain_level, gi_FMWaterBell_release, 0
a_envelope linsegr 0, gi_FMWaterBell_attack, 1, i_sustain, 1, gi_FMWaterBell_release, 0
; ares transegr ia, idur, itype, ib [, idur2] [, itype] [, ic] ...
; a_envelope transegr 0, gi_FMWaterBell_attack, 12, 1, i_sustain, 12, gi_FMWaterBell_sustain_level, gi_FMWaterBell_release, 12, 0
a_signal = a_signal * i_amplitude * a_envelope * k_gain
a_out_left, a_out_right pan2 a_signal, p7
outleta "outleft", a_out_left
outleta "outright", a_out_right
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
; printks "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
endin

gk_Phaser_ratio1 init 1
gk_Phaser_ratio2 init 1/3
gk_Phaser_index1 init 1
gk_Phaser_index2 init 0.0125
gk_Phaser_level init 0.5
gi_Phaser_sine ftgen 0,0,65537,10,1
instr Phaser
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 8
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
isine ftgenonce 0,0,65537,10,1
khertz = ihertz
ifunction1 = gi_Phaser_sine
ifunction2 = gi_Phaser_sine
a1,a2 crosspmi gk_Phaser_ratio1, gk_Phaser_ratio2, gk_Phaser_index1, gk_Phaser_index2, khertz, ifunction1, ifunction2
aleft, aright pan2 a1+a2, p7
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft * kenvelope
aright = adamping * aright * kenvelope
kgain = ampdb(gk_Phaser_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Droner_partial1 init .1
gk_Droner_partial2 init .1
gk_Droner_partial3 init .1
gk_Droner_partial4 init .1
gk_Droner_partial5 init .1
gk_Droner_level init 0.5
gi_Droner_sine ftgen 0, 0, 65537, 10, 1, 0, .02
instr Droner
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
k1 init .5
k2 init .05
k3 init .1
k4 init .2
k5 init .1
k6 init .05
k7 init .1
k8 init 0
k9 init 0
k10 init 0
k3 = gk_Droner_partial1
k4 = gk_Droner_partial2
k5 = gk_Droner_partial3
k6 = gk_Droner_partial4
k7 = gk_Droner_partial5
kwaveform init 0
iamp = ampdb(ivelocity)
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
asignal poscil3 1, ihertz, gi_Droner_sine
asignal chebyshevpoly asignal, 0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10
asignal = asignal * kenvelope * 10
aleft, aright pan2 asignal, p7
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Droner_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Sweeper_britel init 0
gk_Sweeper_briteh init 2.9
gk_Sweeper_britels init .2 / 3
gk_Sweeper_britehs init 2.5 / 2
gk_Sweeper_level init 0.5
instr Sweeper
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity)
gisine ftgenonce 0, 0, 65537, 10, 1
gioctfn ftgenonce 0, 0, 65537, -19, 1, 0.5, 270, 0.5
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
icps = ihertz
kamp expseg 0.001,0.02,0.2,p3-0.01,0.001
ktonemoddep jspline 0.01,0.05,0.2
ktonemodrte jspline 6,0.1,0.2
ktone poscil3 ktonemoddep, ktonemodrte, gisine
kbrite rspline gk_Sweeper_britel, gk_Sweeper_briteh, gk_Sweeper_britels, gk_Sweeper_britehs
ibasfreq init icps
ioctcnt init 3
iphs init 0
a1 hsboscil kenvelope, ktone, kbrite, ibasfreq, gisine, gioctfn, ioctcnt, iphs
amod poscil3 0.25, ibasfreq*(1/3), gisine
arm = a1*amod
irnd1 = unirand(1)
irnd3 = unirand(3)
kmix expseg 0.001, 0.01, irnd1, irnd3+0.3, 0.001
kmix=.25
a1 ntrpol a1, arm, kmix
;a1 pareq a1/10, 400, 15, .707
;a1 tone a1, 500
kpanrte jspline 5, 0.05, 0.1
kpandep jspline 0.9, 0.2, 0.4
kpan poscil3 kpandep, kpanrte, gisine
a1,a2 pan2 a1, p7
irnd01 = unirand(0.1)
a1 delay a1, irnd01
irnd011 = unirand(0.11)
a2 delay a2, irnd011
kenv linsegr 1, 1, 0
kenv = kenvelope
aleft = a1*kenv*.02
aright = a2*kenv*.02
adamping linsegr 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Sweeper_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Buzzer_harmonics init 15
gk_Buzzer_level init .5
instr Buzzer
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 4
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
isine ftgenonce 0, 0, 65537, 10, 1
gk_Harmonics = gk_Buzzer_harmonics
asignal buzz kenvelope, ihertz, gk_Harmonics, isine
asignal = asignal * 3
aleft, aright pan2 asignal, p7
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Buzzer_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Shiner_level init 0.5
instr Shiner
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 4
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
gk_Harmonics = 1 * 20
asignal vco2 kenvelope * 4, ihertz, 12
aleft, aright pan2 asignal, p7
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Shiner_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Blower_grainDensity init 150
gk_Blower_grainDuration init 0.2
gk_Blower_grainAmplitudeRange init 100
gk_Blower_grainFrequencyRange init .033
gk_Blower_level init 2
instr Blower
i_time = p2
i_duration = p3
i_midikey = p4
i_midivelocity = p5
i_phase = p6
i_pan = p6
i_depth = p8
i_height = p9
i_pitchclassset = p10
i_homogeneity = p11
ifrequency = cpsmidinn(i_midikey)
iamplitude = ampdb(i_midivelocity) / 200
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ; f1 0 65537 1 "hahaha.aif" 0 4 0
 ; f2 0 1024 7 0 224 1 800 0
 ; f3 0 8192 7 1 8192 -1
 ; f4 0 1024 7 0 512 1 512 0
 ; f5 0 1024 10 1 .3 .1 0 .2 .02 0 .1 .04
 ; f6 0 1024 10 1 0 .5 0 .33 0 .25 0 .2 0 .167
 ; a0 14 50
 ; p1 p2 p3 p4 p5 p6 p7 p8 p9 p10
 ; Start Dur Amp Freq GrTab WinTab FqcRng Dens Fade
 ; i1 0.0 6.5 700 9.00 5 4 .210 200 1.8
 ; i1 3.2 3.5 800 7.08 . 4 .042 100 0.8
 ; i1 5.1 5.2 600 7.10 . 4 .0320 100 0.9
 ; i1 7.2 6.6 900 8.03 . 4 .021 150 1.6
 ; i1 21.3 4.5 1000 9.00 . 4 .031 150 1.2
 ; i1 26.5 13.5 1100 6.09 . 4 .121 150 1.5
 ; i1 30.7 9.3 900 8.05 . 4 .014 150 2.5
 ; i1 34.2 8.8 700 10.02 . 4 .14 150 1.6
igrtab ftgenonce 0, 0, 65537, 10, 1, .3, .1, 0, .2, .02, 0, .1, .04
iwintab ftgenonce 0, 0, 65537, 10, 1, 0, .5, 0, .33, 0, .25, 0, .2, 0, .167
iHz = ifrequency
ihertz = iHz
ip4 = iamplitude
ip5 = iHz
ip6 = igrtab
ip7 = iwintab
ip8 = 0.033
ip8 = .002
ip9 = 150
ip9 = 100
ip10 = 1.6
ip10 = 3
idur = p3
iamp = iamplitude ; p4
ifqc = iHz ; cpspch(p5)
igrtab = ip6
iwintab = ip7
ifrng = ip8
idens = ip9
ifade = ip10
igdur = 0.2
if p3 == -1 goto indefinite
 goto non_indefinite
indefinite:
 p3 = 1000000
non_indefinite:
iattack = i(gk_overlap) * 2
idecay = i(gk_overlap) * 2
isustain = p3 - i(gk_overlap) * 2
p3 = iattack + isustain + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
kamp = kenvelope
; Amp Fqc Dense AmpOff PitchOff GrDur GrTable WinTable MaxGrDur
aoutl grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
aoutr grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
aleft = aoutl * kamp * iamplitude
aright = aoutr * kamp * iamplitude
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Blower_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_ZakianFlute_midi_dynamic_range init 20
gk_ZakianFlute_level init 0
gk_ZakianFlute_pan init .5
gi_ZakianFLute_seed init .5
instr ZakianFlute
; Author: Lee Zakian
; Adapted by: Michael Gogins
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_velocity = p5
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_overall_amps = 8
i_normalization = ampdb(-i_overall_amps) / 2
i_midi_dynamic_range = i(gk_ZakianFlute_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_ZakianFlute_level)
iattack = .002
isustain = p3
irelease = .3
p3 = iattack + isustain + irelease
iHz = cpsmidinn(i_midi_key)
kHz = k(iHz)
aenvelope transeg 1.0, 20.0, -10.0, 0.05
ip3 = (p3 < 3.0 ? p3 : 3.0)
if2 ftgenonce 0, 0, 16, -2, 40, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 10240
if26 ftgenonce 0, 0, 65537, -10, 2000, 489, 74, 219, 125, 9, 33, 5, 5
if27 ftgenonce 0, 0, 65537, -10, 2729, 1926, 346, 662, 537, 110, 61, 29, 7
if28 ftgenonce 0, 0, 65537, -10, 2558, 2012, 390, 361, 534, 139, 53, 22, 10, 13, 10
if29 ftgenonce 0, 0, 65537, -10, 12318, 8844, 1841, 1636, 256, 150, 60, 46, 11
if30 ftgenonce 0, 0, 65537, -10, 1229, 16, 34, 57, 32
if31 ftgenonce 0, 0, 65537, -10, 163, 31, 1, 50, 31
if32 ftgenonce 0, 0, 65537, -10, 4128, 883, 354, 79, 59, 23
if33 ftgenonce 0, 0, 65537, -10, 1924, 930, 251, 50, 25, 14
if34 ftgenonce 0, 0, 65537, -10, 94, 6, 22, 8
if35 ftgenonce 0, 0, 65537, -10, 2661, 87, 33, 18
if36 ftgenonce 0, 0, 65537, -10, 174, 12
if37 ftgenonce 0, 0, 65537, -10, 314, 13
iwtsin ftgenonce 0, 0, 65537, 10, 1
; parameters
; p4 overall amplitude scaling factor
ip4 init i_amplitude
; p5 pitch in Hertz (normal pitch range: C4-C7)
ip5 init iHz
; p6 percent vibrato depth, recommended values in range [-1., +1.]
ip6 init 0.5
; 0.0 -> no vibrato
; +1. -> 1% vibrato depth, where vibrato rate increases slightly
; -1. -> 1% vibrato depth, where vibrato rate decreases slightly
; p7 attack time in seconds
; recommended value: .12 for slurred notes, .06 for tongued notes
; (.03 for short notes)
ip7 init .08
; p8 decay time in seconds
; recommended value: .1 (.05 for short notes)
ip8 init .08
; p9 overall brightness / filter cutoff factor
; 1 -> least bright / minimum filter cutoff frequency (40 Hz)
; 9 -> brightest / maximum filter cutoff frequency (10,240Hz)
ip9 init 5
; initial variables
iampscale = ip4 ; overall amplitude scaling factor
ifreq = ip5 ; pitch in Hertz
ivibdepth = abs(ip6*ifreq/100.0) ; vibrato depth relative to fundamental frequency
iattack = ip7 * (1.1 - .2*gi_ZakianFLute_seed) ; attack time with up to +-10% random deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947) ; reset gi_ZakianFLute_seed
idecay = ip8 * (1.1 - .2*gi_ZakianFLute_seed) ; decay time with up to +-10% random deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifiltcut tablei ip9, if2 ; lowpass filter cutoff frequency
iattack = (iattack < 6/kr ? 6/kr : iattack) ; minimal attack length
idecay = (idecay < 6/kr ? 6/kr : idecay) ; minimal decay length
isustain = p3 - iattack - idecay
p3 = (isustain < 5/kr ? iattack+idecay+5/kr : p3) ; minimal sustain length
isustain = (isustain < 5/kr ? 5/kr : isustain)
iatt = iattack/6
isus = isustain/4
idec = idecay/6
iphase = gi_ZakianFLute_seed ; use same phase for all wavetables
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
; vibrato block
; kvibdepth linseg .1, .8*p3, 1, .2*p3, .7
kvibdepth linseg .1, .8*ip3, 1, isustain, 1, .2*ip3, .7
kvibdepth = kvibdepth* ivibdepth ; vibrato depth
kvibdepthr randi .1*kvibdepth, 5, gi_ZakianFLute_seed ; up to 10% vibrato depth variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibdepth = kvibdepth + kvibdepthr
ivibr1 = gi_ZakianFLute_seed ; vibrato rate
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ivibr2 = gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
if ip6 < 0 goto vibrato1
kvibrate linseg 2.5+ivibr1, p3, 4.5+ivibr2 ; if p6 positive vibrato gets faster
 goto vibrato2
vibrato1:
ivibr3 = gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibrate linseg 3.5+ivibr1, .1, 4.5+ivibr2, p3-.1, 2.5+ivibr3 ; if p6 negative vibrato gets slower
vibrato2:
kvibrater randi .1*kvibrate, 5, gi_ZakianFLute_seed ; up to 10% vibrato rate variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kvibrate = kvibrate + kvibrater
kvib oscili kvibdepth, kvibrate, iwtsin
ifdev1 = -.03 * gi_ZakianFLute_seed ; frequency deviation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev2 = .003 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev3 = -.0015 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
ifdev4 = .012 * gi_ZakianFLute_seed
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kfreqr linseg ifdev1, iattack, ifdev2, isustain, ifdev3, idecay, ifdev4
kfreq = kHz * (1 + kfreqr) + kvib
if ifreq < 427.28 goto range1 ; (cpspch(8.08) + cpspch(8.09))/2
if ifreq < 608.22 goto range2 ; (cpspch(9.02) + cpspch(9.03))/2
if ifreq < 1013.7 goto range3 ; (cpspch(9.11) + cpspch(10.00))/2
goto range4
; wavetable amplitude envelopes
range1: ; for low range tones
kamp1 linseg 0, iatt, 0.002, iatt, 0.045, iatt, 0.146, iatt, \
0.272, iatt, 0.072, iatt, 0.043, isus, 0.230, isus, 0.000, isus, \
0.118, isus, 0.923, idec, 1.191, idec, 0.794, idec, 0.418, idec, \
0.172, idec, 0.053, idec, 0
kamp2 linseg 0, iatt, 0.009, iatt, 0.022, iatt, -0.049, iatt, \
-0.120, iatt, 0.297, iatt, 1.890, isus, 1.543, isus, 0.000, isus, \
0.546, isus, 0.690, idec, -0.318, idec, -0.326, idec, -0.116, idec, \
-0.035, idec, -0.020, idec, 0
kamp3 linseg 0, iatt, 0.005, iatt, -0.026, iatt, 0.023, iatt, \
0.133, iatt, 0.060, iatt, -1.245, isus, -0.760, isus, 1.000, isus, \
0.360, isus, -0.526, idec, 0.165, idec, 0.184, idec, 0.060, idec, \
0.010, idec, 0.013, idec, 0
iwt1 = if26 ; wavetable numbers
iwt2 = if27
iwt3 = if28
inorm = 3949
goto end
range2: ; for low mid-range tones
kamp1 linseg 0, iatt, 0.000, iatt, -0.005, iatt, 0.000, iatt, \
0.030, iatt, 0.198, iatt, 0.664, isus, 1.451, isus, 1.782, isus, \
1.316, isus, 0.817, idec, 0.284, idec, 0.171, idec, 0.082, idec, \
0.037, idec, 0.012, idec, 0
kamp2 linseg 0, iatt, 0.000, iatt, 0.320, iatt, 0.882, iatt, \
1.863, iatt, 4.175, iatt, 4.355, isus, -5.329, isus, -8.303, isus, \
-1.480, isus, -0.472, idec, 1.819, idec, -0.135, idec, -0.082, idec, \
-0.170, idec, -0.065, idec, 0
kamp3 linseg 0, iatt, 1.000, iatt, 0.520, iatt, -0.303, iatt, \
0.059, iatt, -4.103, iatt, -6.784, isus, 7.006, isus, 11, isus, \
12.495, isus, -0.562, idec, -4.946, idec, -0.587, idec, 0.440, idec, \
0.174, idec, -0.027, idec, 0
iwt1 = if29
iwt2 = if30
iwt3 = if31
inorm = 27668.2
goto end
range3: ; for high mid-range tones
kamp1 linseg 0, iatt, 0.005, iatt, 0.000, iatt, -0.082, iatt, \
0.36, iatt, 0.581, iatt, 0.416, isus, 1.073, isus, 0.000, isus, \
0.356, isus, .86, idec, 0.532, idec, 0.162, idec, 0.076, idec, 0.064, \
idec, 0.031, idec, 0
kamp2 linseg 0, iatt, -0.005, iatt, 0.000, iatt, 0.205, iatt, \
-0.284, iatt, -0.208, iatt, 0.326, isus, -0.401, isus, 1.540, isus, \
0.589, isus, -0.486, idec, -0.016, idec, 0.141, idec, 0.105, idec, \
-0.003, idec, -0.023, idec, 0
kamp3 linseg 0, iatt, 0.722, iatt, 1.500, iatt, 3.697, iatt, \
0.080, iatt, -2.327, iatt, -0.684, isus, -2.638, isus, 0.000, isus, \
1.347, isus, 0.485, idec, -0.419, idec, -.700, idec, -0.278, idec, \
0.167, idec, -0.059, idec, 0
iwt1 = if32
iwt2 = if33
iwt3 = if34
inorm = 3775
goto end
range4: ; for high range tones
kamp1 linseg 0, iatt, 0.000, iatt, 0.000, iatt, 0.211, iatt, \
0.526, iatt, 0.989, iatt, 1.216, isus, 1.727, isus, 1.881, isus, \
1.462, isus, 1.28, idec, 0.75, idec, 0.34, idec, 0.154, idec, 0.122, \
idec, 0.028, idec, 0
kamp2 linseg 0, iatt, 0.500, iatt, 0.000, iatt, 0.181, iatt, \
0.859, iatt, -0.205, iatt, -0.430, isus, -0.725, isus, -0.544, isus, \
-0.436, isus, -0.109, idec, -0.03, idec, -0.022, idec, -0.046, idec, \
-0.071, idec, -0.019, idec, 0
kamp3 linseg 0, iatt, 0.000, iatt, 1.000, iatt, 0.426, iatt, \
0.222, iatt, 0.175, iatt, -0.153, isus, 0.355, isus, 0.175, isus, \
0.16, isus, -0.246, idec, -0.045, idec, -0.072, idec, 0.057, idec, \
-0.024, idec, 0.002, idec, 0
iwt1 = if35
iwt2 = if36
iwt3 = if37
inorm = 4909.05
goto end
end:
kampr1 randi .02*kamp1, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp1 = kamp1 + kampr1
kampr2 randi .02*kamp2, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp2 = kamp2 + kampr2
kampr3 randi .02*kamp3, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
kamp3 = kamp3 + kampr3
awt1 poscil kamp1, kfreq, iwt1, iphase ; wavetable lookup
awt2 poscil kamp2, kfreq, iwt2, iphase
awt3 poscil kamp3, kfreq, iwt3, iphase
asig = awt1 + awt2 + awt3
asig = asig*(iampscale/inorm)
kcut linseg 0, iattack, ifiltcut, isustain, ifiltcut, idecay, 0 ; lowpass filter for brightness control
afilt tone asig, kcut
a_signal balance afilt, asig
i_attack = .002
i_sustain = p3
i_release = 0.01
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
a_signal = a_signal * i_amplitude * a_declicking * k_gain
#ifdef USE_SPATIALIZATION
a_spatial_reverb_send init 0
a_bsignal[] init 16
a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
outletv "outbformat", a_bsignal
outleta "out", a_spatial_reverb_send
#else
a_out_left, a_out_right pan2 a_signal, p7
outleta "outleft", a_out_left
outleta "outright", a_out_right
#endif
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_ReverbSC_feedback init 0.85
gi_ReverbSC_delay_modulation init 0.35
gk_ReverbSC_frequency_cutoff init 15000
instr ReverbSC
ainleft inleta "inleft"
ainright inleta "inright"
; aoutL, aoutR reverbsc ainL, ainR, kfblvl, kfco[, israte[, ipitchm[, iskip]]]
aoutleft, aoutright reverbsc ainleft, ainright, gk_ReverbSC_feedback, gk_ReverbSC_frequency_cutoff, sr, gi_ReverbSC_delay_modulation
; printks "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(aoutleft)), dbamp(rms(aoutright))
outleta "outleft", aoutleft
outleta "outright", aoutright
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_MasterOutput_level init .5
instr MasterOutput
aleft inleta "inleft"
aright inleta "inright"
kgain = ampdb(gk_MasterOutput_level)
outs aleft * kgain, aright * kgain
; fout "Poustinia-v6-7-1.wav", 16, aleft, aright
prints "%-24.24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

instr Controls
k_active chnget "gk_Bower_pressure"
if k_active == 0 goto off_label
prints "Controls on i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
 gk_FMWaterBell_level chnget "gk_FMWaterBell_level"
 gi_FMWaterBell_attack chnget "gi_FMWaterBell_attack"
 gi_FMWaterBell_exponent chnget "gi_FMWaterBell_exponent"
 gi_FMWaterBell_release chnget "gi_FMWaterBell_release"
 gi_FMWaterBell_sustain chnget "gi_FMWaterBell_sustain"
 gi_FMWaterBell_sustain_level chnget "gi_FMWaterBell_sustain_level"
 gk_FMWaterBell_index chnget "gk_FMWaterBell_index"
 gk_FMWaterBell_crossfade chnget "gk_FMWaterBell_crossfade"
 gk_FMWaterBell_vibrato_depth chnget "gk_FMWaterBell_vibrato_depth"
 gk_FMWaterBell_vibrato_rate chnget "gk_FMWaterBell_vibrato_rate"

 gk_Bower_level chnget "gk_Bower_level"
 gk_Bower_pressure chnget "gk_Bower_pressure"
 
 gk_Blower_grainDensity chnget "gk_Blower_grainDensity" 
 gk_Blower_grainDuration chnget "gk_Blower_grainDuration" 
 gk_Blower_grainAmplitudeRange chnget "gk_Blower_grainAmplitudeRange"
 gk_Blower_grainFrequencyRange chnget "gk_Blower_grainFrequencyRange"
 gk_Blower_level chnget "gk_Blower_level" 
 
 gk_Buzzer_harmonics chnget "gk_Buzzer_harmonics" 
 gk_Buzzer_level chnget "gk_Buzzer_level" 
 
 gk_Droner_partial1 chnget "gk_Droner_partial1" 
 gk_Droner_partial2 chnget "gk_Droner_partial2" 
 gk_Droner_partial3 chnget "gk_Droner_partial3" 
 gk_Droner_partial4 chnget "gk_Droner_partial4" 
 gk_Droner_partial5 chnget "gk_Droner_partial5" 
 gk_Droner_level chnget "gk_Droner_level" 
 
 gk_Phaser_ratio1 chnget "gk_Phaser_ratio1" 
 gk_Phaser_ratio2 chnget "gk_Phaser_ratio2" 
 gk_Phaser_index1 chnget "gk_Phaser_index1" 
 gk_Phaser_index2 chnget "gk_Phaser_index2" 
 gk_Phaser_level chnget "gk_Phaser_level" 
 
 gk_PianoteqOut_level chnget "gk_PianoteqOut_level" 
 
 gk_Shiner_level chnget "gk_Shiner_level" 
 
 gk_Sweeper_britel chnget "gk_Sweeper_britel"
 gk_Sweeper_briteh chnget "gk_Sweeper_briteh" 
 gk_Sweeper_britels chnget "gk_Sweeper_britels" 
 gk_Sweeper_britehs chnget "gk_Sweeper_britehs" 
 gk_Sweeper_level chnget "gk_Sweeper_level" 
 
 gk_ZakianFlute_level chnget "gk_ZakianFlute_level"

 gk_Reverb_feedback chnget "gk_MVerb_feedback" 
 gk_Reverb2_feedback chnget "gk_ReverbSC_feedback" 
 gk_MasterOutput_level chnget "gk_MasterOutput_level" 
 gk_overlap chnget "gk_overlap" 
 goto return_label
off_label:
prints "Controls off i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
return_label:
endin

instr exitnow
prints "exitnow i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
 exitnow
endin

</CsInstruments>
<CsScore>
i "exitnow" [9 * 60 + 5 ] .1
</CsScore>
</CsoundSynthesizer>
</textarea>
</div>
<div class="w3-half">
<textarea id="console" rows=100 cols=100 class="w3-code" style="width:100%;height:50vh;box-sizing:border-box;background-color:DarkSlateGrey;color:LawnGreen;">
</textarea>
</div>
<div class="w3-row-padding">
<canvas id="canvas" class="w3-col" style="background:black;width:100%;height:47vh;box-sizing:border-box;">
</canvas>
</div>
<script>
try {
    var fs = require("fs");
    var __dirname = fs.realpathSync.native(".");
} catch(e) {
    console.log(e);
}
</script>
<script src='CsoundAC.js'></script>
<script src='CsoundAudioNode.js'></script>
<script>

var csound_message = function(text) {
    var messages_textarea = document.getElementById("console");
    var existing = messages_textarea.value;
    messages_textarea.value = existing + text;
    messages_textarea.scrollTop = messages_textarea.scrollHeight;
};

var CsoundAC;
(async function() { 
    CsoundAC = await createCsoundAC(); 
    csound_message(CsoundAC.hello()); 
    var txt = "";
    txt += "Browser CodeName: " + navigator.appCodeName + "\n";
    txt += "Browser Name: " + navigator.appName + "\n";
    txt += "Browser Version: " + navigator.appVersion + "\n";
    txt += "Cookies Enabled: " + navigator.cookieEnabled + "\n";
    txt += "Browser Language: " + navigator.language + "\n";
    txt += "Browser Online: " + navigator.onLine + "\n";
    txt += "Platform: " + navigator.platform + "\n";
    txt += "User-agent header: " + navigator.userAgent + "\n";
    csound_message(txt);
}());

var csound;
(async function() {
    csound = await get_csound(csound_message);
    csound.Message("Hello, World, this is Csound!\n");
    }());

var title = document.title;
var csound_score;
var score_model;
var lindenmayer;
var piano_roll = new PianoRoll();

var generate = function() {
  csound.Message("generate()...\n");
  try {
    score_model = new CsoundAC.ScoreModel();
    score_model.setAuthor("Michael Gogins");
    score_model.setYear("2020");
    let scale = new CsoundAC.Scale("C major");
    csound.Message(scale.information());
    let chord = scale.chord(1, 5, 3);
    csound.Message(chord.eOP().information());
    /*
     * A Lindenmayer system consists of a turtle representing a position in 
     * musical space, commands for moving the turtle or writing its state into 
     * a musical score, an axiom or initial set of commands, and zero or more 
     * rules for replacing commands with arbitrary sequences of commands.
     *
     * The turtle T represents the current state of the Lindenmayer system. 
     * The turtle consists of a note vector N that represents a position in 
     * musical space, a step size S, an orientation O, a chord C, a chord 
     * defining modality M, an octavewise chord revoicing V, a scale Sc, a 
     * scale degree Sd, and a range Ra. Turtle commands are defined 
     * `(operation target ...)` or `(operation target[dimension] ...)`:
     *
     * ([ T)        Push the current turtle state on a stack (start a branch).
     * (] T)        Pop the current turtle state from the stack (return to 
     *              the branching point).
     * (W N e)      Write the current turtle position as a note into the score
     *              under equivalence class e (0, O, R).
     * (F N x e)    Move the turtle position N "forward" x steps S along its 
     *              current orientation O) under equivalence class e 
     *              (0, O, R): 
     *              N := N + (x * S * O).
     * (o N[d] x e) Apply algebraic operation o (=, +, -, *, /) to dimension d 
     *              (i, t, d, k, v, p, x, y, z, s) of the turtle position N 
     *              with parameter x under equivalence class e (0, O, R):
     *              N[d] := N[d] + S[d] o x.
     * (o S[d] x e) Apply algebraic operation o (=, +, -, *, /) to dimension d 
     *              (i, t, d, k, v, p, x, y, z, s) of the turtle step size S
     *              with parameter x under equivalence class e (0, O, R):
     *              S[d] := S[d] + S[d] o x.
     * (R O d1 d2)  Rotate the turtle orientation O in the plane of dimensions 
     *              d1 and d2 by angle x radians:
     *              R = makeRotation(d, e, x); O := R * O.
     * (W C e)      Write the current turtle chord C with voicing V to the 
     *              score under equivalence class e (0, O, R). This chord will 
     *              default to the same instrument and other dimensions as the 
     *              current turtle note N.
     * (o C v e)    Apply algebraic operation o (=, +, -, *, /) to the turtle 
     *              chord C as a whole with parameter v (a vector or chord name) 
     *              under equivalence class e (0, O, R):
     *              C := C o x.
     * (o C[i] x e) Apply algebraic operation o (=, +, -, *, /) to voice i 
     *              of the turtle chord C with parameter x under equivalence 
     *              class e (0, O, R):
     *              C[i] := C[i] o v.
     * (o M v e)    Apply algebraic operation o (=, +, -, *, /) to the turtle 
     *              modality M as a whole with parameter v (a vector or chord 
     *              name) under equivalence class e (0, O, R):
     *              M := M o v.
     * (o M[i] x e) Apply algebraic operation o (=, +, -, *, /) to voice i 
     *              of the turtle modality M with parameter x under 
     *              equivalence class e (0, O, R):
     *              M[i] := M[i] o x.
     * (o V x)      Apply algebraic operation o (=, +, -, *, /) to the voicing 
     *              index of the turtle chord with parameter x: 
     *              V := V o x. Of necessity the equivalence class is the 
     *              range of the score.
     * (I C x)      Invert the turtle chord C by reflecting it around 
     *              pitch-class x.
     * (K C)        Apply Neo-Riemannian inversion by exchange to the turtle 
     *              chord C.
     * (Q C x)      Apply Neo-Riemannian contextual transposition by x 
     *              pitch-classes (with reference to the turtle's modality M) 
     *              to the turtle chord C.
     * (+ C)        Add a voice (doubling the root) to the turtle chord C.
     * (- C)        Remove a voice (the uppermost) from the turtle chord C.
     * (o Sd x)     Apply algebraic operation o (=, +, -, *, /) to the turtle 
     *              scale degree Sd, with parameter x.
     * (C Sd m)     Obtain the turtle chord C of m voices as the current scale 
     *              degree Sd degree of the turtle scale Sc.
     * (C Sc n m)   Obtain the turtle chord C with m voices as the nth degree 
     *              of the turtle scale Sc.
     * (o Sc x)     Apply algebraic operation o (=, +, -, *, /) to the turtle 
     *              scale Sc; x may be a scalar, a vector to define the scale, 
     *              or the name of a scale.
     * (M Sc n k)   Modulate the turtle scale Sc to a new scale Sc with the 
     *              common chord at the current scale degree with n voices; if 
     *              there is more than one scale with that common chord, 
     *              choose the kth scale.
     * (C P)        Apply the current turtle chord C to the score, starting at 
     *              the current time and continuing until the next A command.
     * (C P L)      Apply the current turtle chord C to the score, using the 
     *              closest voice-leading from the previous chord (if any), 
     *              starting at the current time and continuing to the next 
     *              chord or scale.
     * (Sc P)       Apply the current turtle scale Sc to the score, starting 
     *              at the current time and continuing until the next chord 
     *              or scale.
     * (0 P)        End the scope of the previous chord or scale.   
     * (= P n)      Assign the range n to the size of the score, i.e. define 
     *              range equivalence.
     *
     * An arithmetic operation may also consist of sampling a random 
     * distribution, e.g. (u N[k] minimum maximum); the parameters of the 
     * distribution must be given. All the arithmetic operations are:
     *
     * Assignment           = x e
     * Addition             + x e
     * Subtraction          - x e
     * Multiplication       * x e
     * Division             / x e
     * Uniform              uni min max
     * Normal (Gaussian)    nor mean sigma min max
     * Binomial             bin p k min max
     * Negative binomial    nbi p k min max
     * Poisson              poi min max
     * Exponential          exp lambda min max
     * Gamma                gam alpha beta min max
     * Weibull              wei a b min max
     * Extreme value        ext a b min max
     * Log normal           log mean sigma min max
     * Chi squared          chi n min max
     * Cauchy               cau a b min max
     * Fisher               fis m n min max
     * Student              stu n min max
     *
     * PLEASE NOTE: Scale commands take precedence over chord commands. Not 
     * all commands are implemented. Unimplemented commands silently perform 
     * no operations, but may still be used to define replacement rules.
     */
    lindenmayer = new CsoundAC.ChordLindenmayer();
    lindenmayer.setAxiom("(seed P 3928394)(R P 60)(= N[d] 3)(Sc P)(A)");
    lindenmayer.addRule("(A)", "(A)(W N)(+ N[k] 20 R)(C Sd 5 R)(W C R)(- Sd 2)([)(+ N[k] 7)(/ S[t] 1.025)(/ S[d] 1.025)(F N 1)(A)(])(uni V 1 24)(uni N[x] 0 1)(+ N[t] 1)(W C R)(C Sd 3)(uni N[i] 1 5)(M Sc 3 0)(Sc P)(W N)(A)(- N[k] 2)(+ N[t] 1)(W N)(A)");
    lindenmayer.setIterationCount(3);
    csound.Message("lindenmayer: " + lindenmayer);
    var rescale = new CsoundAC.Rescale();
    rescale.setRescale(0, true, false, 1., 0.);
    rescale.setRescale(3, true, true, 1., 8.);
    rescale.setRescale(4, true, false, 30., 72.);
    rescale.setRescale(5, true, true, 60., 12.);
    //CsoundAC.System.setMessageLevel(15);
    rescale.addChild(lindenmayer);
    score_model.addChild(rescale);
    score_model.generate();
    score = score_model.getScore();
    score.setDuration(5 * 60);
    csound_score = score.getCsoundScore(12., true);
    piano_roll.draw3D(score, canvas);
  } catch(err) {
    csound.Message(err.name + ': ' + err.message + ' ' + err.line + '\n');
  }
};

// Message level for standard (terminal) output. Takes the sum of any of the following values:
// 1 = note amplitude messages
// 2 = samples out of range message
// 4 = warning messages
// 128 = print benchmark information
// And exactly one of these to select note amplitude format:
// 0 = raw amplitudes, no colours
// 32 = dB, no colors
// 64 = dB, out of range highlighted with red
// 96 = dB, all colors
// 256 = raw, out of range highlighted with red
// 512 = raw, all colours    
var render = function(output_name, post_process) {
    var csd = document.getElementById('csd').value;
    csound_score = score.getCsoundScore(12., true);
    csound_score = csound_score.concat("\n</CsScore>");
    csd = csd.replace("</CsScore>", csound_score);
    csound.Message("Playing...");
    csound.setOption(sprintf('-m%d', 2 + 128 + 32));
    csound.setOption('--nodisplays');
    csound.setOption('--keep-sorted-score');
    csound.setOption('-R');
    csound.setOption('-W');
    csound.setOption('-f');
    csound.setOption('-o' + output_name);
    csound.compileCsdText(csd);
    csound.Message("Rendering...");
    csound.start();
    csound.perform();
    updateScoreTime();
}

var render_audio = function() {
    render("dac:plughw:1", false);
}

var render_soundfile = function() {
    render(title + ".wav", false);
}

var render_soundfile_and_postprocess = function() {
    render(title + ".wav", true);
}

var stop = function() {
    csound.stop();
}

var updateScoreTime = function() {
    var score_time = csound.getScoreTime();
    setTimeout(updateScoreTime, 200);
    piano_roll.progress3D(score_time);
};
var gk_update = function(name, value) {
    var numberValue = parseFloat(value);
    csound.setControlChannel(name, numberValue);
};

var add_slider = function(gui_folder, token, minimum, maximum, name) {
    var on_parameter_change = function(value) {
    gk_update(token, value);
    };
    gui_folder.add(parameters, token, minimum, maximum).onChange(on_parameter_change);
};

window.addEventListener("unload", function(event) { 
parameters.stop();
nw_window.close();
});

var parameters = {
     gk_FMWaterBell_level: 15,
     gi_FMWaterBell_attack: 0.002,
     gi_FMWaterBell_release: 0.01,
     gi_FMWaterBell_exponent: 15,
     gi_FMWaterBell_sustain: 20,
     gi_FMWaterBell_sustain_level: .1,
     gk_FMWaterBell_index: .5,
     gk_FMWaterBell_crossfade: .5,
     gk_FMWaterBell_vibrato_depth: 0.05,
     gk_FMWaterBell_vibrato_rate: 6,
     gk_Bower_level: 0.5,
     gk_Bower_pressure: 0.25,
     gk_Blower_grainDensity: .150,
     gk_Blower_grainDuration: .2,
     gk_Blower_grainAmplitudeRange: .1,
     gk_Blower_grainFrequencyRange: .033,
     gk_Blower_level: 0.5,
     gk_Buzzer_harmonics: 15,
     gk_Buzzer_level: 0.5,
     gk_Droner_partial1: 0.1,
     gk_Droner_partial2: 0.1,
     gk_Droner_partial3: 0.1,
     gk_Droner_partial4: 0.1,
     gk_Droner_partial5: 0.1,
     gk_Droner_level: 30,
     gk_Phaser_ratio1: 1,
     gk_Phaser_ratio2: .3333334,
     gk_Phaser_index1: 1,
     gk_Phaser_index2: .0125,
     gk_Phaser_level: 0.5,
     gk_Shiner_level: 0.5,
     gk_Sweeper_britel: 0,
     gk_Sweeper_briteh: 2.9,
     gk_Sweeper_britels: .2 / 3,
     gk_Sweeper_britehs: 2.5 / 2,
     gk_Sweeper_level: 0.5,
     gk_ZakianFlute_level: 0,
     gk_ReverbSC_feedback: .8,
     gk_MasterOutput_level: .4,
     generate: window.generate,
     render_audio: window.render_audio,
     render_soundfile: window.render_soundfile,
     render_soundfile_and_postprocess: window.render_soundfile_and_postprocess,
     stop: window.stop,
};

window.addEventListener("load", function() {
    try {
        gui = new dat.GUI({width: 400});
        gui.remember(parameters);
        gui.add(parameters, 'generate').name('Generate [Ctrl-G]');
        gui.add(parameters, 'render_audio').name('Render audio [Ctrl-A]');
        gui.add(parameters, 'render_soundfile').name('Render soundfile');
        gui.add(parameters, 'render_soundfile_and_postprocess').name('Render/post [Ctrl-P]');
        gui.add(parameters, 'stop').name('Stop [Ctrl-S]');
        var Master = gui.addFolder('Master');
        add_slider(Master, 'gk_ReverbSC_feedback', 0, 1);
        add_slider(Master, 'gk_MasterOutput_level', -40, 40);
        var FMWaterBell = gui.addFolder('FMWaterBell');
        add_slider(FMWaterBell, 'gi_FMWaterBell_attack', 0, .1);
        add_slider(FMWaterBell, 'gi_FMWaterBell_release', 0, .1);
        add_slider(FMWaterBell, 'gi_FMWaterBell_exponent', -30, 30);
        add_slider(FMWaterBell, 'gi_FMWaterBell_sustain', 0, 20);
        add_slider(FMWaterBell, 'gi_FMWaterBell_sustain_level', 0, 1);
        add_slider(FMWaterBell, 'gk_FMWaterBell_crossfade', 0, 1);
        add_slider(FMWaterBell, 'gk_FMWaterBell_index', 0, 15);
        add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_depth', 0, 10);
        add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_rate', 0, 10);
        add_slider(FMWaterBell, 'gk_FMWaterBell_level',-40, 40);
        var Phaser = gui.addFolder('Phaser');
        add_slider(Phaser, 'gk_Phaser_ratio1', 0, 5);
        add_slider(Phaser, 'gk_Phaser_ratio2', 0, 5);
        add_slider(Phaser, 'gk_Phaser_index1', 0, 15);
        add_slider(Phaser, 'gk_Phaser_index2', 0, 15);
        add_slider(Phaser, 'gk_Phaser_level', -40, 40);
        var Bower = gui.addFolder('Bower');
        add_slider(Bower, 'gk_Bower_pressure', 0, 5);
        add_slider(Bower, 'gk_Bower_level', -40, 40);
        var Droner = gui.addFolder('Droner');
        add_slider(Droner, 'gk_Droner_partial1', 0, 1);
        add_slider(Droner, 'gk_Droner_partial2', 0, 1);
        add_slider(Droner, 'gk_Droner_partial3', 0, 1);
        add_slider(Droner, 'gk_Droner_partial4', 0, 1);
        add_slider(Droner, 'gk_Droner_partial5', 0, 1);
        add_slider(Droner, 'gk_Droner_level', -40, 40);
        var Sweeper = gui.addFolder('Sweeper');
        add_slider(Sweeper, 'gk_Sweeper_britel', 0, 4);
        add_slider(Sweeper, 'gk_Sweeper_briteh', 0, 4);
        add_slider(Sweeper, 'gk_Sweeper_britels', 0, 4);
        add_slider(Sweeper, 'gk_Sweeper_britehs', 0, 4);
        add_slider(Sweeper, 'gk_Sweeper_level', -40, 40);
        var Buzzer = gui.addFolder('Buzzer');
        add_slider(Buzzer, 'gk_Buzzer_harmonics', 0, 20);
        add_slider(Buzzer, 'gk_Buzzer_level', -40, 40);
        var Shiner = gui.addFolder('Shiner');
        add_slider(Shiner, 'gk_Shiner_level', -40, 40);
        var Blower = gui.addFolder('Blower');
        add_slider(Blower, 'gk_Blower_grainDensity', 0, 400);
        add_slider(Blower, 'gk_Blower_grainDuration', 0, .5);
        add_slider(Blower, 'gk_Blower_grainAmplitudeRange', 0, 400);
        add_slider(Blower, 'gk_Blower_grainFrequencyRange', 0, 100);
        add_slider(Blower, 'gk_Blower_level', -40, 40);
        var Flute = gui.addFolder('Zakian Flute');
        add_slider(Flute, 'gk_ZakianFlute_level', -40, 40);
        gui.revert(); 
        document.addEventListener("keydown", function (e) {
            var e_char = String.fromCharCode(e.keyCode || e.charCode);
            if (e.ctrlKey === true) {
                if (e_char === 'H') {
                    var console = document.getElementById("console");
                    if (console.style.display === "none") {
                        console.style.display = "block";
                    } else {
                        console.style.display = "none";
                    }
                    gui.closed = true;
                    gui.closed = false;
                } else if (e_char === 'G') {
                    generate();
                } else if (e_char === 'P') {
                    parameters.play();
                } else if (e_char === 'S') {
                    parameters.stop();
                }
            }
        });
    } catch (e) {
        console.error(e);
    };
});
</script>
</body>
</html>